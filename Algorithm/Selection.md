# 선택(selection) 문제

- 입력: n개의 값과 k값(1 ≤ k ≤ n)
- 출력: k번째로 작은 입력 값
- 목표: 비교 횟수의 최소화 (upper bound를 낮추기)

- 항상 n번 이하의 비교로 충분히 문제 해결 가능한 경우 → 비교 횟수 n = 상한(upper bound)
- 반드시 최소한 n번 이상의 비교가 필요한 경우 → 비교 횟수 n = 하한(lower bound)

<br/>

**예시**

**최댓값 찾는 문제**

1. method 1 처음부터 하나씩 비교 → n-1번 비교
2. method 2 토너먼트 식으로 두 개씩 짝 지어서 비교 → n-1번 비교
- n-1 (상한 = 하한)  두 경우 모두 딱 필요한 만큼의 비교 횟수는 항상 n-1번

<br/>

**최댓값과 최솟값 찾는 문제**

 1. method 1 

- 처음부터 하나씩 n-1번 비교 → 최댓값 찾고
- 최댓값을 제외한 값끼리 n-2번 비교 → 최솟값 찾기
- 총 2n-3번 비교 (상한)
 2. method 2
- 토너먼트 식으로 n-1번 비교 → 최댓값 찾고
- 토너먼트에서 탈락한 n/2개의 값에서 (n/2 - 1)번 비교 → 최솟값 찾기
- 총 (3n/2 - 2)번 비교 (상한 = 하한)

<br/>

**가장 작은 값과 2번째로 작은 값 찾는 문제**

 1. method 1 

- 처음부터 하나씩 n-1번 비교 → 최솟값 찾고
- 최솟값을 제외한 값끼리 n-2번 비교 → 다시 최솟값 찾기
- 총 2n-3번 비교 (상한)
 2. method 2
- 토너먼트 식으로 n-1번 비교 → 최솟값 찾고
- 가장 작은 값과 경기를 한 값들 중에 2번째로 작은 값이 존재함
- log n개의 값들 중에서 (log n - 1)번 비교 → 2번째 최솟값 찾기
- 총 (n + log n - 2)번 비교 (상한 = 하한)

<br/>
<br/>

## Quick select 알고리즘

- 구현방법
    1. 기준값 p(pivot)를 고른다 (random or 첫 번째 항목 or 마지막 항목 ...)
    2. p보다 작은 값들(A)과 p보다 큰 값들(B), p와 같은 값들(M)을 각각 비교해서 구분(n-1번 비교)
    3. A에 들어있는 값의 개수가 k보다 크면 (if |A| > k: ) 
    
          k번째 값은 무조건 A안에 존재함! ⇒ A안에서 k번째로 작은 값을 찾아야 함(재귀적으로!)
    
    4. A값의 개수 + M값의 개수가 k 보다 작다면 (elif |A| + |M| < k: )                    
    
          k번째 값은 무조건 B안에 존재함! ⇒ B안에서 (k - |A| - |M|)번째 값을 찾아야 함
    
    5. k가 M에 존재한다면 (else: )
    
          k번째 값은 p와 같으므로 return p
    

```python
def quick_select(L, k):
	"""리스트 L에서 정수 k번째 값을 찾아서 리턴하는 함수"""
	p = L[0]                  # pivot = 첫번째 항목으로 설정
	
	A, B, M = [], [], []      # 각 값을 비교해서 저장할 리스트
	for x in L:               # 각각의 항목에 대해서
		if p > x: A.append(x)   # p보다 작은 값
    elif p < x: B.append(x) # p보다 큰 값
		else: M.append(x)       # p와 같은 값
	
	if len(A) > k: return quick_select(A, k)
	elif len(A) + len(M) < k: return quick_select(B, k-len(A)-len(M))
	else: return p
```

- worst case : 값이 A 또는 B쪽으로 몰리는 경우 (p가 최대 or 최솟값) → 재귀 호출이 n-1번 필요

      비교 횟수 T(n) = T(n-1) + n = (T(n-2) + n-1) + n = ... = T(1) + (2+3+4+... + n-1 + n) = O(n^2)

- best case: A와 B가 비슷한 크기로 나눠지는 경우 → 재귀 호출 횟수의 최소화

      비교 횟수 T(n) = T(n/2) + n = (T(n^2^2) + n/2) + n = ... = T(1) + n(1/2^(k-1) + .. + 1/2 + 1) = O(n)
